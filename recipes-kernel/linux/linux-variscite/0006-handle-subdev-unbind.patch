From d9b2ce0bbccb462f394d4b1ce311418f766cac56 Mon Sep 17 00:00:00 2001
From: Thies Moeller <thies.moeller@baslerweb.com>
Date: Fri, 25 Jun 2021 16:19:25 +0200
Subject: [PATCH 06/15] handle subdev unbind

---
 .../media/platform/mxc/capture/mx6s_capture.c | 24 ++++++--
 .../media/platform/mxc/capture/mxc_mipi_csi.c | 58 ++++++++++++++-----
 3 files changed, 72 insertions(+), 23 deletions(-)

diff --git a/drivers/media/platform/mxc/capture/mx6s_capture.c b/drivers/media/platform/mxc/capture/mx6s_capture.c
index cbd4cb4c0a38..ab6d7ed261c3 100644
--- a/drivers/media/platform/mxc/capture/mx6s_capture.c
+++ b/drivers/media/platform/mxc/capture/mx6s_capture.c
@@ -1818,13 +1818,13 @@ static const struct v4l2_ioctl_ops mx6s_csi_ioctl_ops = {
 };
 
 static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
-			    struct v4l2_subdev *subdev,
-			    struct v4l2_async_subdev *asd)
+				 struct v4l2_subdev *subdev,
+				 struct v4l2_async_subdev *asd)
 {
 	struct mx6s_csi_dev *csi_dev = notifier_to_mx6s_dev(notifier);
 
-	if (subdev == NULL)
-		return -EINVAL;
+	BUG_ON(subdev == NULL || csi_dev->sd != NULL);
+
 
 	/* Find platform data for this sensor subdev */
 	if (csi_dev->fwnode == dev_fwnode(subdev->dev))
@@ -1836,6 +1836,21 @@ static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
 	return 0;
 }
 
+static void subdev_notifier_unbind(struct v4l2_async_notifier *notifier,
+				   struct v4l2_subdev *subdev,
+				   struct v4l2_async_subdev *asd)
+{
+	struct mx6s_csi_dev *csi_dev = notifier_to_mx6s_dev(notifier);
+
+	BUG_ON(subdev == NULL);
+
+	if (subdev == csi_dev->sd)
+		csi_dev->sd = NULL;
+
+	v4l2_info(&csi_dev->v4l2_dev, "Unregistered sensor subdevice: %s\n",
+		  subdev->name);
+}
+
 static int mx6s_csi_mode_sel(struct mx6s_csi_dev *csi_dev)
 {
 	struct device_node *np = csi_dev->dev->of_node;
@@ -1882,6 +1897,7 @@ static int mx6s_csi_mode_sel(struct mx6s_csi_dev *csi_dev)
 
 static const struct v4l2_async_notifier_operations mx6s_capture_async_ops = {
 	.bound = subdev_notifier_bound,
+	.unbind = subdev_notifier_unbind,
 };
 
 static int mx6s_csi_two_8bit_sensor_mode_sel(struct mx6s_csi_dev *csi_dev)
diff --git a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
index f0ddcc1f52bf..912cf2fa63de 100644
--- a/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
+++ b/drivers/media/platform/mxc/capture/mxc_mipi_csi.c
@@ -926,18 +926,28 @@ static irqreturn_t mipi_csis_irq_handler(int irq, void *dev_id)
 }
 
 static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
-			    struct v4l2_subdev *subdev,
-			    struct v4l2_async_subdev *asd)
+				 struct v4l2_subdev *subdev,
+				 struct v4l2_async_subdev *asd)
 {
 	struct csi_state *state = notifier_to_mipi_dev(notifier);
 
+	BUG_ON(subdev == NULL || state->sensor_sd != NULL);
+
+	if (subdev == NULL)
+		return -EINVAL;
+
 	/* Find platform data for this sensor subdev */
 	if (state->fwnode == dev_fwnode(subdev->dev))
 		state->sensor_sd = subdev;
 
-	if (subdev == NULL)
-		return -EINVAL;
+	/* Initialize our control handler */
+	v4l2_ctrl_handler_init(&state->ctrl_handler, 10);
+	if (state->ctrl_handler.error) {
+		return state->ctrl_handler.error;
+	}
+	state->mipi_sd.ctrl_handler = &state->ctrl_handler;
 
+	/* Merge subdev handler into our handler */
 	v4l2_ctrl_add_handler(state->mipi_sd.ctrl_handler, subdev->ctrl_handler,
 		  NULL, true);
 
@@ -947,6 +957,28 @@ static int subdev_notifier_bound(struct v4l2_async_notifier *notifier,
 	return 0;
 }
 
+static void subdev_notifier_unbind(struct v4l2_async_notifier *notifier,
+				   struct v4l2_subdev *subdev,
+				   struct v4l2_async_subdev *asd)
+{
+	struct csi_state *state = notifier_to_mipi_dev(notifier);
+
+	BUG_ON(subdev == NULL);
+
+	if (subdev == state->sensor_sd)
+	{
+		if (state->mipi_sd.ctrl_handler) {
+			state->mipi_sd.ctrl_handler = NULL;
+			v4l2_ctrl_handler_free(&state->ctrl_handler);
+		}
+
+		state->sensor_sd = NULL;
+	}
+
+	v4l2_info(&state->v4l2_dev, "Unregistered sensor subdevice: %s\n",
+		  subdev->name);
+}
+
 static int mipi_csis_parse_dt(struct platform_device *pdev,
 			    struct csi_state *state)
 {
@@ -987,6 +1019,7 @@ static const struct of_device_id mipi_csis_of_match[];
 
 static const struct v4l2_async_notifier_operations mxc_mipi_csi_subdev_ops = {
 	.bound = subdev_notifier_bound,
+	.unbind = subdev_notifier_unbind,
 };
 
 /* register parent dev */
@@ -1139,20 +1172,12 @@ static int mipi_csis_probe(struct platform_device *pdev)
 		goto e_clkdis;
 	}
 
-	/* Add the control handler */
-	v4l2_ctrl_handler_init(&state->ctrl_handler, 10);
-	if (state->ctrl_handler.error) {
-		ret = state->ctrl_handler.error;
-		goto e_clkdis;
-	}
-	state->mipi_sd.ctrl_handler = &state->ctrl_handler;
-
 	/* First register a v4l2 device */
 	ret = v4l2_device_register(dev, &state->v4l2_dev);
 	if (ret) {
 		v4l2_err(dev->driver,
 			"Unable to register v4l2 device.\n");
-		goto e_handler;
+		goto e_clkdis;
 	}
 	v4l2_info(&state->v4l2_dev, "mipi csi v4l2 device registered\n");
 
@@ -1189,8 +1214,6 @@ static int mipi_csis_probe(struct platform_device *pdev)
 	v4l2_device_unregister(&state->v4l2_dev);
 e_sd_mipi:
 	v4l2_async_unregister_subdev(&state->mipi_sd);
-e_handler:
-	v4l2_ctrl_handler_free(&state->ctrl_handler);
 e_clkdis:
 	mipi_csis_clk_disable(state);
 	return ret;
@@ -1292,7 +1315,10 @@ static int mipi_csis_remove(struct platform_device *pdev)
 	v4l2_async_notifier_cleanup(&state->subdev_notifier);
 	v4l2_async_notifier_unregister(&state->subdev_notifier);
 	v4l2_device_unregister(&state->v4l2_dev);
-	v4l2_ctrl_handler_free(&state->ctrl_handler);
+	if (state->mipi_sd.ctrl_handler) {
+		state->mipi_sd.ctrl_handler = NULL;
+		v4l2_ctrl_handler_free(&state->ctrl_handler);
+	}
 
 	pm_runtime_disable(&pdev->dev);
 	mipi_csis_pm_suspend(&pdev->dev, true);
-- 
2.33.0

